#!/usr/bin/env python -i

import os
import sys
import time
import random
import spadic

# setup
#====================================================================

print 'initializing...'
s = spadic.Spadic()
c = spadic.Controller(s)
r = spadic.MessageReader(s)

# for interactive use
c.set_directmode(True)


# configs
#====================================================================

def config_ftdireadtest(direct=True, quiet=False):
    mode = c._directmode
    c.set_directmode(False) # avoid numerous write operations
    c.reset()

    c.testdata(testdatain=True, testdataout=True)
    c.digital.channel[0](enable=True)

    if direct:
        if not quiet:
            print 'writing configuration...'
        c.apply()
    c.set_directmode(mode)

#--------------------------------------------------------------------

def config_analogtest(channel, direct=True, quiet=False):
    mode = c._directmode
    c.set_directmode(False) # avoid numerous write operations
    c.reset()

    
    # global analog settings
    c.frontend(frontend='P', baseline=64,
               psourcebias=60, nsourcebias=60,
               pcasc=60, ncasc=60, xfb=60)
    c.adcbias(vndel=70, vpdel=100, vploadfb=70,
              vploadfb2=70, vpfb=70, vpamp=70)

    # global digital settings
    c.filter.stage[4](scaling=0.5, norm=True, offset=128, enable=1)
    c.comparator(threshold1=20, threshold2=30, diffmode=0)
    c.hitlogic(mask=0xFFFFF000, window=20)
    c.testdata(testdatain=1, testdataout=1,
               group={0: 'A', 1: 'B'}[channel//16])

    # channel settings
    c.digital.channel[channel](enable=1)
    c.frontend.channel[channel](baseline=64, enablecsa=1, enableadc=1)

    if direct:
        if not quiet:
            print 'writing configuration...'
        c.apply()
    c.set_directmode(mode)

#--------------------------------------------------------------------

def config_adctest(channel, direct=True, quiet=False):
    mode = c._directmode
    c.set_directmode(False) # avoid numerous write operations
    c.reset()
    
    # global analog settings
    c.frontend(frontend='P', baseline=0,
               psourcebias=60, nsourcebias=60,
               pcasc=60, ncasc=60, xfb=60)
    c.adcbias(vndel=70, vpdel=100, vploadfb=70,
              vploadfb2=70, vpfb=70, vpamp=70)

    # global digital settings
    c.hitlogic(mask=0xFFFF0000, window=16)
    c.testdata(testdatain=1, testdataout=1, group='A')

    # setup channel 0 --> channel x trigger
    c.digital.channel[0](enable=True)
    c.digital.channel[channel](enable=True)
    c.digital.neighbor['A'](source=0, target=channel, enable=1)
    c.frontend.channel[channel](baseline=64, enablecsa=1, enableadc=1)

    if direct:
        if not quiet:
            print 'writing configuration...'
        c.apply()
    c.set_directmode(mode)


# utility
#====================================================================

def stdout(s):
    """Write to stdout and flush buffer."""
    sys.stdout.write(s)
    sys.stdout.flush()

#--------------------------------------------------------------------

def ledtest():
    """Turn one LED on and off."""
    mode = c._directmode
    c.set_directmode(True)
    c.led(1, 0)
    c.led(0, 0)
    c.set_directmode(mode)

#--------------------------------------------------------------------

def randdata(n):
    """Generate a list of random numbers."""
    return [random.randint(0, 120) for i in range(n)]

#--------------------------------------------------------------------
    
def ftdiflush(max_timeout=1, timeout_init=1e-6):
    """Read from FTDI until empty."""
    start = time.time()
    timeout = timeout_init
    while True:
        d = s._ftdi_read(9, 1)
        if d:
            timeout = timeout_init
            yield d
        else:
            if timeout > max_timeout:
                break
            time.sleep(timeout)
            timeout = 2*timeout

#--------------------------------------------------------------------
    
def ftdireadtest(f=None, max_timeout=1, timeout_init=1e-6):
    """Read from FTDI until empty, and print as hexadecimal codes."""
    start = time.time()
    timeout = timeout_init
    print >> f, ''
    while True:
        d = s._ftdi_read(9, 1)
        if d:
            timeout = timeout_init
            print >> f, '%6.1f: ' % (time.time()-start) + \
                        ' '.join('%02X' % x for x in d)
        else:
            if timeout > max_timeout:
                break
            time.sleep(timeout)
            timeout = 2*timeout

#--------------------------------------------------------------------

def quickwrite(data):
    """Write data to channel 0 and read back from received messages."""
    for i in range(4):
        s.write_data(data)
        time.sleep(0.1)
    M = r.read()
    if M:
        return M[-1].data
    else:
        print 'no messages found!'

#--------------------------------------------------------------------

def ask_overwrite(filename):
    if os.path.isfile(filename):
        answer = raw_input('file \'%s\' already exists. overwrite? [y/n] '
                           % filename)
        write = True if answer and answer in 'yY' else False
                     # ('' in 'yY') == True !!!
    else:
        write = True
    return write


# measurements
#====================================================================

def measure_baseline(channels):
    mode = c._directmode
    c.set_directmode(False)

    baseline = {}

    for ch in channels:
        print 'baseline measurement for channel', ch
        print '-----------------------------------'

        stdout('writing configuration... ')
        config_adctest(ch, direct=False, quiet=True)
        c.digital.channel[ch](enable=False)
        c.apply()

        print('enable channel %i... ' % ch)
        c.set_directmode(True)
        c.digital.channel[ch](enable=True)

        stdout('flushing FTDI buffers... ')
        ftdicount = 0
        ftdistr = '%i bytes' % ftdicount
        stdout(ftdistr)
        for d in ftdiflush():
            ftdicount += len(d)
            stdout('\b'*len(ftdistr))
            ftdistr = '%i bytes' % ftdicount
            stdout(ftdistr)
        for i in range(5):
            s.write_data([100, 150])
            time.sleep(0.1)
        for d in ftdiflush():
            ftdicount += len(d)
            stdout('\b'*len(ftdistr))
            ftdistr = '%i bytes' % ftdicount
            stdout(ftdistr)
        stdout('\n')

        b = []

        for j in range(10):
            stdout('writing data')
            for i in range(5):
                stdout('.')
                s.write_data([100, 150])
                time.sleep(0.1)

            stdout(' reading messages...')
            try:
                M = r.read()
            except: # many things can go wrong, just proceed then
                for d in ftdiflush():
                    pass
                M = []
            stdout(' found %i' % len(M))
            b += [x for m in M if m.channel_id==ch
                    for x in (m.data if m.data is not None else [])]
            stdout('\n')

        stdout('\n')
        baseline[ch] = b

    c.set_directmode(mode)
    return baseline

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

def save_baseline(baseline, filename, sep='\n'):
    """Write measured baselines to file.
    
    Use '\\n' as separator to produce a file suitable as input for gnuplot,
    or e.g. ' ' for fitting more data on a  page.
    """
    write_permission = ask_overwrite(filename)
    if write_permission:
        sys.stdout.write('writing file... ')
        sys.stdout.flush()
        with open(filename, 'w') as f:
            for ch in sorted(baseline):
                f.write('# channel %i' % ch)
                f.write('\n')
                f.write(sep.join(str(x) for x in baseline[ch]))
                f.write('\n'*3)
        sys.stdout.write('done.\n')
    else:
        print 'not writing to file.'


