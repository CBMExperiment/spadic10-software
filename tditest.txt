data written repeatedly to IOM addr 0x30:
 82 99 44 50 44 28 25 4 39 70

after each repetition, one of the following blocks was received from test
data out (package port --> first byte FF already removed)

 A0 00 BE E3 A2 20 20 00
 22 A9 63 26 2C 44 B2 33
 A0 00 BE EB AE 36 25 22
 23 3D 26 20 20 00 20 00

 20 00 20 00 B3 30 A0 00
 B8 0B A2 20 20 00 22 A9
 63 26 2C 44 B2 33 A0 00
 B8 13 AE 36 25 22 23 3D
 26 20 20 00 20 00 20 00

 20 00 B3 30 A0 00 B9 5C
 A2 20 20 00 22 A9 63 26
 2C 44 B2 33 A0 00 B9 66
 AE 36 25 22 23 3D 26 20
 20 00 20 00 20 00 20 00

 B3 30 A0 00 B2 BB A2 20
 20 00 22 A9 63 26 2C 44
 B2 33 A0 00 B2 A3 AE 36
 25 22 23 3D 26 20 20 00
 20 00 20 00 20 00 B3 30

 A0 00 B5 D1 A2 20 20 00
 22 A9 63 26 2C 44 B2 33
 A0 00 B5 D9 AE 36 25 22
 23 3D 26 20 20 00 20 00

trying to find repeating pattern:

 A0 00 BE E3

 A2 20 20 00 22 A9 63 26 2C 44 B2 33 A0 00 BE EB
 AE 36 25 22 23 3D 26 20 20 00 20 00 20 00 20 00
 B3 30 A0 00 B8 0B
 
 A2 20 20 00 22 A9 63 26 2C 44 B2 33 A0 00 B8 13
 AE 36 25 22 23 3D 26 20 20 00 20 00 20 00 20 00
 B3 30 A0 00 B9 5C
 
 A2 20 20 00 22 A9 63 26 2C 44 B2 33 A0 00 B9 66
 AE 36 25 22 23 3D 26 20 20 00 20 00 20 00 20 00
 B3 30 A0 00 B2 BB
 
 A2 20 20 00 22 A9 63 26 2C 44 B2 33 A0 00 B2 A3
 AE 36 25 22 23 3D 26 20 20 00 20 00 20 00 20 00
 B3 30 A0 00 B5 D1
 
 A2 20 20 00 22 A9 63 26 2C 44 B2 33 A0 00 B5 D9
 AE 36 25 22 23 3D 26 20 20 00 20 00

--> found blocks of 38 bytes with many identical bytes

marking the bytes that differ from block to block:

  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 
  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 
  .  . A0 00 (BE E3)

 A2 20 20 00 22 A9 63 26 2C 44 B2 33 A0 00 (BE EB)
 AE 36 25 22 23 3D 26 20 20 00 20 00 20 00 20 00
 B3 30 A0 00 (B8 0B)
 
 A2 20 20 00 22 A9 63 26 2C 44 B2 33 A0 00 (B8 13)
 AE 36 25 22 23 3D 26 20 20 00 20 00 20 00 20 00
 B3 30 A0 00 (B9 5C)
 
 A2 20 20 00 22 A9 63 26 2C 44 B2 33 A0 00 (B9 66)
 AE 36 25 22 23 3D 26 20 20 00 20 00 20 00 20 00
 B3 30 A0 00 (B2 BB)
 
 A2 20 20 00 22 A9 63 26 2C 44 B2 33 A0 00 (B2 A3)
 AE 36 25 22 23 3D 26 20 20 00 20 00 20 00 20 00
 B3 30 A0 00 (B5 D1)
 
 A2 20 20 00 22 A9 63 26 2C 44 B2 33 A0 00 (B5 D9)
 AE 36 25 22 23 3D 26 20 20 00 20 00  .  .  .  .
  .  .  .  .  .  .

what if the data is aligned at these changing bytes?

 ( .  .)  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . A0 00
 (BE E3) A2 20 20 00 22 A9 63 26 2C 44 B2 33 A0 00
 (BE EB) AE 36 25 22 23 3D 26 20 20 00 20 00 20 00 20 00 B3 30 A0 00
 (B8 0B) A2 20 20 00 22 A9 63 26 2C 44 B2 33 A0 00
 (B8 13) AE 36 25 22 23 3D 26 20 20 00 20 00 20 00 20 00 B3 30 A0 00
 (B9 5C) A2 20 20 00 22 A9 63 26 2C 44 B2 33 A0 00
 (B9 66) AE 36 25 22 23 3D 26 20 20 00 20 00 20 00 20 00 B3 30 A0 00
 (B2 BB) A2 20 20 00 22 A9 63 26 2C 44 B2 33 A0 00
 (B2 A3) AE 36 25 22 23 3D 26 20 20 00 20 00 20 00 20 00 B3 30 A0 00
 (B5 D1) A2 20 20 00 22 A9 63 26 2C 44 B2 33 A0 00
 (B5 D9) AE 36 25 22 23 3D 26 20 20 00 20 00  .  .  .  .  .  .  .  .

let's try to find the numbers that were sent to the test input:

  82  99  44  50  44  28  25   4  39  70

they are the bits [8:1] of the 9 bit that make up one sample, the LSB is
always 0. the values that should be contained in the messages should then
be:

 164 198  88 100  88  56  50   8  78 140 

in their 9 bit representation they are:

 164: 010100100
 198: 011000110
  88: 001011000
 100: 001100100
  88: 001011000
  56: 000111000
  50: 000110010
   8: 000001000
  78: 001001110
 140: 010001100

the concatenation of all bitstrings must be somewhere in the data. there are
four possibilities for the bitstring to be aligned in 4-bit (i.e.
hexadecimal character) steps:

 ---- 1 ----  ---- 2 ----  ---- 3 ----  ---- 4 ----
 0101 0010 0  0 1010 0100  01 0100 100  010 1001 00
 011 0001 10  0110 0011 0  0 1100 0110  01 1000 110
 00 1011 000  001 0110 00  0010 1100 0  0 0101 1000
 0 0110 0100  00 1100 100  001 1001 00  0011 0010 0
 0010 1100 0  0 0101 1000  00 1011 000  001 0110 00
 000 1110 00  0001 1100 0  0 0011 1000  00 0111 000
 00 0110 010  000 1100 10  0001 1001 0  0 0011 0010
 0 0000 1000  00 0001 000  000 0010 00  0000 0100 0
 0010 0111 0  0 0100 1110  00 1001 110  001 0011 10
 010 0011 00  0100 0110 0  0 1000 1100  01 0001 100

 1: 0101 0010 0011 0001 1000 1011 0000 0110 0100 0010 1100 0000
    1110 0000 0110 0100 0000 1000 0010 0111 0010 0011 00..

 2: ...0 1010 0100 0110 0011 0001 0110 0000 1100 1000 0101 1000
    0001 1100 0000 1100 1000 0001 0000 0100 1110 0100 0110 0...
  
 3: ..01 0100 1000 1100 0110 0010 1100 0001 1001 0000 1011 0000
    0011 1000 0001 1001 0000 0010 0000 1001 1100 1000 1100
 
 4: .010 1001 0001 1000 1100 0101 1000 0011 0010 0001 0110 0000
    0111 0000 0011 0010 0000 0100 0001 0011 1001 0001 100.

the hexadecimal representation is then:

 1: 5 2 3 1 8 B 0 6 4 2 C 0
    E 0 6 4 0 8 2 7 2 3 .

 2: . A 4 6 3 1 6 0 C 8 5 8
    1 C 0 C 8 1 0 4 E 4 6 .
  
 3: . 4 8 C 6 2 C 1 9 0 B 0
    3 8 1 9 0 2 0 9 C 8 C
 
 4: . 9 1 8 C 5 8 3 2 1 6 0
    7 0 3 2 0 4 1 3 9 1 .

combining two hex-characters to one byte (2 possibilities):

 1a: 52 31 8B 06 42 C0   1b: .5 23 18 B0 64 2C 
     E0 64 08 27 23          0E 06 40 82 72 3.
                        
 2a: .A 46 31 60 C8 58   2b: A4 63 16 0C 85 81
     1C 0C 81 04 E4 6.       C0 C8 10 4E 46 
                          
 3a: .4 8C 62 C1 90 B0   3b: 48 C6 2C 19 0B 03
     38 19 02 09 C8 C.       81 90 20 9C 8C
                         
 4a: .9 18 C5 83 21 60   4b: 91 8C 58 32 16 07
     70 32 04 13 91          03 20 41 39 1.

remember what we found:

 (B. ..) A2 20 20 00 22 A9 63 26 2C 44 B2 33 A0 00
 (B. ..) AE 36 25 22 23 3D 26 20 20 00 20 00 20 00 20 00 B3 30 A0 00

closest similarity: version 2b
 (.. ..) .. .. .. .. .. A4 63 16 0C 85 81 C0 C8 10
 (4E 46) .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. ..

idea: invert test data out bits (16 possibilities...)

