data written repeatedly to IOM addr 0x30:
 82 99 44 50 44 28 25 4 39 70

after each repetition, one of the following blocks was received from test
data out (package port --> first byte FF already removed)

 A0 00 BE E3 A2 20 20 00
 22 A9 63 26 2C 44 B2 33
 A0 00 BE EB AE 36 25 22
 23 3D 26 20 20 00 20 00

 20 00 20 00 B3 30 A0 00
 B8 0B A2 20 20 00 22 A9
 63 26 2C 44 B2 33 A0 00
 B8 13 AE 36 25 22 23 3D
 26 20 20 00 20 00 20 00

 20 00 B3 30 A0 00 B9 5C
 A2 20 20 00 22 A9 63 26
 2C 44 B2 33 A0 00 B9 66
 AE 36 25 22 23 3D 26 20
 20 00 20 00 20 00 20 00

 B3 30 A0 00 B2 BB A2 20
 20 00 22 A9 63 26 2C 44
 B2 33 A0 00 B2 A3 AE 36
 25 22 23 3D 26 20 20 00
 20 00 20 00 20 00 B3 30

 A0 00 B5 D1 A2 20 20 00
 22 A9 63 26 2C 44 B2 33
 A0 00 B5 D9 AE 36 25 22
 23 3D 26 20 20 00 20 00

trying to find repeating pattern:

 A0 00 BE E3

 A2 20 20 00 22 A9 63 26 2C 44 B2 33 A0 00 BE EB
 AE 36 25 22 23 3D 26 20 20 00 20 00 20 00 20 00
 B3 30 A0 00 B8 0B
 
 A2 20 20 00 22 A9 63 26 2C 44 B2 33 A0 00 B8 13
 AE 36 25 22 23 3D 26 20 20 00 20 00 20 00 20 00
 B3 30 A0 00 B9 5C
 
 A2 20 20 00 22 A9 63 26 2C 44 B2 33 A0 00 B9 66
 AE 36 25 22 23 3D 26 20 20 00 20 00 20 00 20 00
 B3 30 A0 00 B2 BB
 
 A2 20 20 00 22 A9 63 26 2C 44 B2 33 A0 00 B2 A3
 AE 36 25 22 23 3D 26 20 20 00 20 00 20 00 20 00
 B3 30 A0 00 B5 D1
 
 A2 20 20 00 22 A9 63 26 2C 44 B2 33 A0 00 B5 D9
 AE 36 25 22 23 3D 26 20 20 00 20 00

--> found blocks of 38 bytes with many identical bytes

marking the bytes that differ from block to block:

  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 
  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 
  .  . A0 00 (BE E3)

 A2 20 20 00 22 A9 63 26 2C 44 B2 33 A0 00 (BE EB)
 AE 36 25 22 23 3D 26 20 20 00 20 00 20 00 20 00
 B3 30 A0 00 (B8 0B)
 
 A2 20 20 00 22 A9 63 26 2C 44 B2 33 A0 00 (B8 13)
 AE 36 25 22 23 3D 26 20 20 00 20 00 20 00 20 00
 B3 30 A0 00 (B9 5C)
 
 A2 20 20 00 22 A9 63 26 2C 44 B2 33 A0 00 (B9 66)
 AE 36 25 22 23 3D 26 20 20 00 20 00 20 00 20 00
 B3 30 A0 00 (B2 BB)
 
 A2 20 20 00 22 A9 63 26 2C 44 B2 33 A0 00 (B2 A3)
 AE 36 25 22 23 3D 26 20 20 00 20 00 20 00 20 00
 B3 30 A0 00 (B5 D1)
 
 A2 20 20 00 22 A9 63 26 2C 44 B2 33 A0 00 (B5 D9)
 AE 36 25 22 23 3D 26 20 20 00 20 00  .  .  .  .
  .  .  .  .  .  .

what if the data is aligned at these changing bytes?

 ( .  .)  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . A0 00
 (BE E3) A2 20 20 00 22 A9 63 26 2C 44 B2 33 A0 00
 (BE EB) AE 36 25 22 23 3D 26 20 20 00 20 00 20 00 20 00 B3 30 A0 00
 (B8 0B) A2 20 20 00 22 A9 63 26 2C 44 B2 33 A0 00
 (B8 13) AE 36 25 22 23 3D 26 20 20 00 20 00 20 00 20 00 B3 30 A0 00
 (B9 5C) A2 20 20 00 22 A9 63 26 2C 44 B2 33 A0 00
 (B9 66) AE 36 25 22 23 3D 26 20 20 00 20 00 20 00 20 00 B3 30 A0 00
 (B2 BB) A2 20 20 00 22 A9 63 26 2C 44 B2 33 A0 00
 (B2 A3) AE 36 25 22 23 3D 26 20 20 00 20 00 20 00 20 00 B3 30 A0 00
 (B5 D1) A2 20 20 00 22 A9 63 26 2C 44 B2 33 A0 00
 (B5 D9) AE 36 25 22 23 3D 26 20 20 00 20 00  .  .  .  .  .  .  .  .

let's try to find the numbers that were sent to the test input:

  82  99  44  50  44  28  25   4  39  70

they are the bits [8:1] of the 9 bit that make up one sample, the LSB is
always 0. the values that should be contained in the messages should then
be:

 164 198  88 100  88  56  50   8  78 140 

in their 9 bit representation they are:

 164: 010100100
 198: 011000110
  88: 001011000
 100: 001100100
  88: 001011000
  56: 000111000
  50: 000110010
   8: 000001000
  78: 001001110
 140: 010001100

the concatenation of all bitstrings must be somewhere in the data (*). there
are four possibilities for the bitstring to be aligned in 4-bit (i.e.
hexadecimal character) steps:

    (*) I made a mistake here, forgot to first combine to 15 bit blocks and
        prepend a 0 before each --> see "trying to find repeating pattern,
        version 2"

 ---- 1 ----  ---- 2 ----  ---- 3 ----  ---- 4 ----
 0101 0010 0  0 1010 0100  01 0100 100  010 1001 00
 011 0001 10  0110 0011 0  0 1100 0110  01 1000 110
 00 1011 000  001 0110 00  0010 1100 0  0 0101 1000
 0 0110 0100  00 1100 100  001 1001 00  0011 0010 0
 0010 1100 0  0 0101 1000  00 1011 000  001 0110 00
 000 1110 00  0001 1100 0  0 0011 1000  00 0111 000
 00 0110 010  000 1100 10  0001 1001 0  0 0011 0010
 0 0000 1000  00 0001 000  000 0010 00  0000 0100 0
 0010 0111 0  0 0100 1110  00 1001 110  001 0011 10
 010 0011 00  0100 0110 0  0 1000 1100  01 0001 100

 1: 0101 0010 0011 0001 1000 1011 0000 0110 0100 0010 1100 0000
    1110 0000 0110 0100 0000 1000 0010 0111 0010 0011 00..

 2: ...0 1010 0100 0110 0011 0001 0110 0000 1100 1000 0101 1000
    0001 1100 0000 1100 1000 0001 0000 0100 1110 0100 0110 0...
  
 3: ..01 0100 1000 1100 0110 0010 1100 0001 1001 0000 1011 0000
    0011 1000 0001 1001 0000 0010 0000 1001 1100 1000 1100
 
 4: .010 1001 0001 1000 1100 0101 1000 0011 0010 0001 0110 0000
    0111 0000 0011 0010 0000 0100 0001 0011 1001 0001 100.

the hexadecimal representation is then:

 1: 5 2 3 1 8 B 0 6 4 2 C 0
    E 0 6 4 0 8 2 7 2 3 .

 2: . A 4 6 3 1 6 0 C 8 5 8
    1 C 0 C 8 1 0 4 E 4 6 .
  
 3: . 4 8 C 6 2 C 1 9 0 B 0
    3 8 1 9 0 2 0 9 C 8 C
 
 4: . 9 1 8 C 5 8 3 2 1 6 0
    7 0 3 2 0 4 1 3 9 1 .

combining two hex-characters to one byte (2 possibilities):

 1a: 52 31 8B 06 42 C0   1b: .5 23 18 B0 64 2C 
     E0 64 08 27 23          0E 06 40 82 72 3.
                        
 2a: .A 46 31 60 C8 58   2b: A4 63 16 0C 85 81
     1C 0C 81 04 E4 6.       C0 C8 10 4E 46 
                          
 3a: .4 8C 62 C1 90 B0   3b: 48 C6 2C 19 0B 03
     38 19 02 09 C8 C.       81 90 20 9C 8C
                         
 4a: .9 18 C5 83 21 60   4b: 91 8C 58 32 16 07
     70 32 04 13 91          03 20 41 39 1.

remember what we found:

 (B. ..) A2 20 20 00 22 A9 63 26 2C 44 B2 33 A0 00
 (B. ..) AE 36 25 22 23 3D 26 20 20 00 20 00 20 00 20 00 B3 30 A0 00

closest similarity: version 2b
 (.. ..) .. .. .. .. .. A4 63 16 0C 85 81 C0 C8 10
 (4E 46) .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. ..

idea: maybe some test data out bits are inverted (lvds P/N mistake...)
--> no, the polarity is correct for all bits

---------------------------------------------------------------------
trying to find repeating pattern, version 2:

why not start with the first byte...?

 A0 00 (BE E3) A2 20 20 00 22 A9 63 26 2C 44 B2 33
 A0 00 (BE EB) AE 36 25 22 23 3D 26 20 20 00 20 00 20 00 20 00 B3 30
 A0 00 (B8 0B) A2 20 20 00 22 A9 63 26 2C 44 B2 33
 A0 00 (B8 13) AE 36 25 22 23 3D 26 20 20 00 20 00 20 00 20 00 B3 30
 A0 00 (B9 5C) A2 20 20 00 22 A9 63 26 2C 44 B2 33
 A0 00 (B9 66) AE 36 25 22 23 3D 26 20 20 00 20 00 20 00 20 00 B3 30
 A0 00 (B2 BB) A2 20 20 00 22 A9 63 26 2C 44 B2 33
 A0 00 (B2 A3) AE 36 25 22 23 3D 26 20 20 00 20 00 20 00 20 00 B3 30
 A0 00 (B5 D1) A2 20 20 00 22 A9 63 26 2C 44 B2 33
 A0 00 (B5 D9) AE 36 25 22 23 3D 26 20 20 00 20 00 .. .. .. .. .. ..

 now, the only bytes that changed are at positions 3+4, which is where we
 would expect the timestamp word!
 
 we would expect the first two 16-bit words of a normal message to begin
 with 8 (SOM) and 9 (TSW), respectively. we found A and B.
 
 8: 1000  9: 1001
 A: 1010  B: 1011

 the third 16-bit word in our data always begins with A. this is the raw
 data marker, as we expect it!

 the last 16-bit word in our data always begins with B. this is EOM!

 in the middle part of our data we find many 20s where we would expect 00s.
 but we do find 00s as well.
 which leads to the following theory:

 for each 16-bit word [15:0], the bit [13] is always 1. that would lead to
 the following conversion of 16-bit words on their way out of the test data
 output:

 0. ..: 0000 .... .... .... --> 0010 .... .... ....: 2. ..
 1. ..: 0001 .... .... .... --> 0011 .... .... ....: 3. ..
 2. ..: 0010 .... .... .... --> 0010 .... .... ....: 2. .. (ok)
 3. ..: 0011 .... .... .... --> 0011 .... .... ....: 3. .. (ok)
 4. ..: 0100 .... .... .... --> 0110 .... .... ....: 6. ..
 5. ..: 0101 .... .... .... --> 0111 .... .... ....: 7. ..
 6. ..: 0110 .... .... .... --> 0110 .... .... ....: 6. .. (ok)
 7. ..: 0111 .... .... .... --> 0111 .... .... ....: 7. .. (ok)
 8. ..: 1000 .... .... .... --> 1010 .... .... ....: A. ..
 9. ..: 1001 .... .... .... --> 1011 .... .... ....: B. ..
 A. ..: 1010 .... .... .... --> 1010 .... .... ....: A. .. (ok)
 B. ..: 1011 .... .... .... --> 1011 .... .... ....: B. .. (ok)
 C. ..: 1100 .... .... .... --> 1110 .... .... ....: E. ..
 D. ..: 1101 .... .... .... --> 1111 .... .... ....: F. ..
 E. ..: 1110 .... .... .... --> 1110 .... .... ....: E. .. (ok)
 F. ..: 1111 .... .... .... --> 1111 .... .... ....: F. .. (ok)

let's try to manually fix the bit errors by correcting the SOM and TSW:

 80 00 9E E3 A2 20 20 00 22 A9 63 26 2C 44 B2 33
 80 00 9E EB AE 36 25 22 23 3D 26 20 20 00 20 00 20 00 20 00 B3 30
 80 00 98 0B A2 20 20 00 22 A9 63 26 2C 44 B2 33
 80 00 98 13 AE 36 25 22 23 3D 26 20 20 00 20 00 20 00 20 00 B3 30
 80 00 99 5C A2 20 20 00 22 A9 63 26 2C 44 B2 33
 80 00 99 66 AE 36 25 22 23 3D 26 20 20 00 20 00 20 00 20 00 B3 30
 80 00 92 BB A2 20 20 00 22 A9 63 26 2C 44 B2 33
 80 00 92 A3 AE 36 25 22 23 3D 26 20 20 00 20 00 20 00 20 00 B3 30
 80 00 95 D1 A2 20 20 00 22 A9 63 26 2C 44 B2 33

each line interpreted as a message
(note how the bits in this column are always 1 except where we corrected
manually:)
       |
  0: 1000000000000000
  1: 1001111011100011
  2: 1010001000100000
  3: 0010000000000000
  4: 0010001010101001
  5: 0110001100100110
  6: 0010110001000100
  7: 1011001000110011
group: 0
channel: 0
timestamp: 3811
data (8 values): 68, 16, 0, 138, -178, 100, -106, 68
hit type: int+ext hit
stop type: multi hit

  0: 1000000000000000
  1: 1001111011101011
  2: 1010111000110110
  3: 0010010100100010
  4: 0010001100111101
  5: 0010011000100000
  6: 0010000000000000
  7: 0010000000000000
  8: 0010000000000000
  9: 0010000000000000
 10: 1011001100110000
group: 0
channel: 0
timestamp: 3819
data (12 values): -58, -110, -222, 140, -22, 196, 16, 0, 128, 2, 0, 16
hit type: int+ext hit
stop type: normal end of message

  0: 1000000000000000
  1: 1001100000001011
  2: 1010001000100000
  3: 0010000000000000
  4: 0010001010101001
  5: 0110001100100110
  6: 0010110001000100
  7: 1011001000110011
group: 0
channel: 0
timestamp: 2059
data (8 values): 68, 16, 0, 138, -178, 100, -106, 68
hit type: int+ext hit
stop type: multi hit

  0: 1000000000000000
  1: 1001100000010011
  2: 1010111000110110
  3: 0010010100100010
  4: 0010001100111101
  5: 0010011000100000
  6: 0010000000000000
  7: 0010000000000000
  8: 0010000000000000
  9: 0010000000000000
 10: 1011001100110000
group: 0
channel: 0
timestamp: 2067
data (12 values): -58, -110, -222, 140, -22, 196, 16, 0, 128, 2, 0, 16
hit type: int+ext hit
stop type: normal end of message

  0: 1000000000000000
  1: 1001100101011100
  2: 1010001000100000
  3: 0010000000000000
  4: 0010001010101001
  5: 0110001100100110
  6: 0010110001000100
  7: 1011001000110011
group: 0
channel: 0
timestamp: 2396
data (8 values): 68, 16, 0, 138, -178, 100, -106, 68
hit type: int+ext hit
stop type: multi hit

  0: 1000000000000000
  1: 1001100101100110
  2: 1010111000110110
  3: 0010010100100010
  4: 0010001100111101
  5: 0010011000100000
  6: 0010000000000000
  7: 0010000000000000
  8: 0010000000000000
  9: 0010000000000000
 10: 1011001100110000
group: 0
channel: 0
timestamp: 2406
data (12 values): -58, -110, -222, 140, -22, 196, 16, 0, 128, 2, 0, 16
hit type: int+ext hit
stop type: normal end of message

  0: 1000000000000000
  1: 1001001010111011
  2: 1010001000100000
  3: 0010000000000000
  4: 0010001010101001
  5: 0110001100100110
  6: 0010110001000100
  7: 1011001000110011
group: 0
channel: 0
timestamp: 699
data (8 values): 68, 16, 0, 138, -178, 100, -106, 68
hit type: int+ext hit
stop type: multi hit

  0: 1000000000000000
  1: 1001001010100011
  2: 1010111000110110
  3: 0010010100100010
  4: 0010001100111101
  5: 0010011000100000
  6: 0010000000000000
  7: 0010000000000000
  8: 0010000000000000
  9: 0010000000000000
 10: 1011001100110000
group: 0
channel: 0
timestamp: 675
data (12 values): -58, -110, -222, 140, -22, 196, 16, 0, 128, 2, 0, 16
hit type: int+ext hit
stop type: normal end of message

  0: 1000000000000000
  1: 1001010111010001
  2: 1010001000100000
  3: 0010000000000000
  4: 0010001010101001
  5: 0110001100100110
  6: 0010110001000100
  7: 1011001000110011
group: 0
channel: 0
timestamp: 1489
data (8 values): 68, 16, 0, 138, -178, 100, -106, 68
hit type: int+ext hit
stop type: multi hit

let's try again to find the values we sent in:
 164 198  88 100  88  56  50   8  78 140 

010100100
011000110
001011000
001100100
001011000
000111000
000110010
000001000
001001110
010001100

we always get one message with 'multi hit' as stop type and then one with a
TS increased by 8 and 'normal end of message' as stop type. the data values
are, if we combine the two messages:

  68  16
   0 138 -178 100 -106  68 -58 -110 -222 140
 -22 196   16   0  128   2   0   16

001000100
000010000
000000000
010001010
101001110
001100100
110010110
001000100
111000110
110010010
100100010
010001100
111101010
011000100
000010000
000000000
010000000
000000010
000000000
000010000

